# LS220_DSA

## DSA book:

# [data structures and algorithms](https://github.com/SandyRodger/launch_school_books/blob/main/data_structures_and_algorithms.md#data-structures-and-algorithms)
# [Introduction](https://github.com/SandyRodger/launch_school_books/blob/main/data_structures_and_algorithms.md#introduction)
# [How DSA gives you an edge[]()](https://github.com/SandyRodger/launch_school_books/blob/main/data_structures_and_algorithms.md#how-dsa-gives-you-an-edge)
# [Technical interviews: many focus on DSA](https://github.com/SandyRodger/launch_school_books/blob/main/data_structures_and_algorithms.md#technical-interviews-many-focus-on-dsa)
# [Efficient Problem solving:]([)](https://github.com/SandyRodger/launch_school_books/blob/main/data_structures_and_algorithms.md#efficient-problem-solving)
# [Building a strong foundation]([)](https://github.com/SandyRodger/launch_school_books/blob/main/data_structures_and_algorithms.md#building-a-strong-foundation)
# [What we'll cover](https://github.com/SandyRodger/launch_school_books/blob/main/data_structures_and_algorithms.md#what-well-cover)
# [PEDAC]((https://github.com/SandyRodger/launch_school_books/blob/main/data_structures_and_algorithms.md#pedac)
# [sorting algorithms](https://github.com/SandyRodger/launch_school_books/blob/main/data_structures_and_algorithms.md#sorting-algorithms)
# [algorithm techniques](https://github.com/SandyRodger/launch_school_books/blob/main/data_structures_and_algorithms.md#algorithm-techniques)
# [essential data structures]()
# [Practice for mastery]()
# [going deeper]()
# [let's get started]()
# [THE PEDAC APPROACH TO PROBLEM SOLVING]()
# [INTRODUCTION TO DATA STRUCTURES AND ALGORITHMS]()
# [Why Data Structures Matter]()
# [What are Data Structures?]()
# [The Benefits of Data Structures]()
# [Code Efficiency]()
# [Algorithm design]()
# [Problem solving]()
# [A Real-world Example]()
# [Why Algorithms Matter]()
# [What are algorithms?]()
# [Choosing an algorithm]()
# [Introduction to Big O Notation]()
# [Time complexities]()
# [Big O]()
# [Exploring Time Complexities]()
# [O(1)]()
# [O(logN)]()
# [logarithms]()
# [exponent]()
# [O(N)]()
# [O(NlogN)]()
# [O(N^2)]()
# [O(N^3)]()
# [O(2^N)]()
# [O(N!)]()
# [Space Complexity]()
# [Auxiliary Space Complexity]()
# [Fine-tuning Time Complexity]()
# [Removing constants from time complexity]()
# [The arbitrary name "N"]()
# [Distinct variable names for different collections]()
# [Time & Space Complexity Problems]()
# [Practice problems]()
# [Algorithm Discovery Process]()
# [Pushing the Big O curve down 1 level]()
# [Hash Tables]()
# [Practice: Find a Majority Element]()
# [Problem descrption]()
# [SORTING ALGORITHMS]()
# [Intro to Sorting Algorithms]()
# [Real World Applications]()
# [Bubble Sort]()
# [Selection Sort]()
# [Insertion Sort]()
# [POINTER-BASED MENTAL MODELS]()
# [Pointer-Based Strategies]()
# [Two Pointers: Start/End]()
# [Two Pointers: Anchor/Runner]()
# [Reader-writer variant]()
# [Practice: Reverse Consonants]()
# [Practice: Compress to Distinct]()
# [BINARY SEARCH]()
# [Intro to Binary Search]()
# [Binary Search Template]()
# [Tempate:]()
# [Demo: Find Zero Position]()
# [Demo: Find The Range of Threes]()
# [Practice: Minimum Count]()
# [LINKED LISTS]()
# [Intro to Linked Lists]()
# [Arrays vs Linked Lists]()
# [The Structure of a Linked List]()
# [Types of Linked Lists]()
# [Implementing a Linked List]()
# [Arrays vs Linked Lists Performance]()
# [Reading]()
# [Searching]()
# [Inserting]()
# [Deleting]()
# [When to Use Linked Lists?]()
# [Insertion & Deletion]()
# [Demo: Remove Twos]()
# [Problem Description]()
# [Algorithm]()
# [Walkthrough]()
# [Solution Code]()
# [Pointers in Linked Lists]()
# [Dummy Nodes in Linked Lists]()
# [Demo: Reverse Linked List]()
# [Practice: Remove Every Second]()
# [STACKS & QUEUES]()
# [Intro to Stacks and Queues]()
# [Core Characteristics]()
# [Stacks]()
# [Key operations]()
# [Practical Applications of Stacks]()
# [Function call management]()
# [Undo mechanisms in Applications]()
# [Web Browser Nevigation]()
# [Depth-first Search (DFS) in Graphs]()
# [Implement Stack with Linked List]()
# [Queues]()
# [Key operations]()
# [Practical applications of queues]()
# [Implement Queue using Linked List]()
# [Stacks and Queues in Interviews]()
# [When to use a Stack]()
# [When to use a queue]()
# [Practice: Matching Brackets]()
# [CONCLUSION]()

# Advanced DSA book:

# [INTRODUCTION TO RECURSION]()
# [Understanding Recursion]()
# [Example Problem]()
# [More Terminology]()
# [Call Stack in Recursive Algorithms]()
# [Understanding the Call Stack]()
# [The Call Stack and Non-recursive Function Calls]()
# [The Call Stack and Recursive Function Calls]()
# [The factorial function]()
# [Stack Overflow]()
# [Recursion: Time & Space Analysis]()
# [Time Complexity]()
# [Factorial Function]()
# [Fibonacci Function]()
# [Space Complexity]()
# [Space Complexity of the Factorial Algorithm:]()
# [Space Complexity of the Fibonacci Algorithm:]()
# [Fibonacci Call Stack]()
# [The Function Signature]()
# [Helper Functions]()
# [dynamic programming]()
# [Demo: Valid Palindrome String]()
# [Problem Description]()
# [Recursive Definition]()
# [Implementation]()
# [Practice: Sum of Natural Numbers]()
# [DIVIDE AND CONQUER ALGORITHMS]()
# [Intro to Divide and Conquer Algorithms]()
# [Divide:]()
# [Conquer:]()
# [Combine]()
# [Quicksort: Partitioning]()
# [Algorithm]()
# [steps:]()
# [Quicksort: Adding Recursion]()
# [Quicksort: Pivot Element Position]()
# [implementation]()
# [Divide & Conquer in Quicksort]()
# [Divide]()
# [Conquer]()
# [Combine]()
# [QuickSort Time Complexity]()
# [Partitioning Step]()
# [Recursive step]()
# [Combining the Partitioning and recursion steps]()
# [DYNAMIC PROGRAMMING]()
# [Intro to Dynamic Programming]()
# [Two Strategies]()
# [Time complexity]()
# [When to use DP]()
# [DP vs DnC]()
# [Demo: Hopping Chaos I]()
# [Time and space complexity]()
# [Demo: Hopping Chaos II]()
# [Problem description]()
# [Bottom-up walkthrough]()
# [Solution]()
# [Time and space complexity]()
# [DP Caching: Arrays vs. Maps]()
# [Demo: Chaos in the Grid (Bottom-Up)]()
# [Demo: Chaos in the Grid (Top-Down)]()
# [Top-Down vs. Bottom-Up Approach]()
# [Practice: Chaos in Grid with Cats]()
# [BINARY TREES]()
# [Intro to Trees]()
# [Terminology]()
# [Binary Trees]()
# [Key properties of Binary trees]()
# [Representing a Binary Tree in Javascript]()
# [Time and Space COmplexities of Binary Tree Operations]()
# [Types of Binary Trees]()
# [Full Binary Tree]()
# [Complete Binary Tree]()
# [Perfect Binary Tree]()
# [Balanced Binary Tree]()
# [Divide & Conquer in Tree Problems]()
# [A complimentary duo]()
# [Practice: Binary Tree Height]()
# [Tree Traversal: DFS and BFS]()
# [Binary Tree Traversal]()
# [Depth-First Search]()
# [Preorder Traversal]()
# [Inorder Traversal]()
# [PostOrder Traversal]()
# [Breadth-First Search]()
# [Practice: Preorder Traversal]()
# [Practice: Inorder Traversal]()
# [Practice: Postorder Traversal]()
# [Practice: Level Order Traversal]()
# [Binary Search Tree]()
# [Time and Space Complexities of Binary Search Tree Operations]()
# [Practice: Find Node in a BST]()
# [GRAPHS]()
# [Introduction to Graphs]()
# [why graphs matter in the real world]()
# [Types of Graphs]()
# [Directed and Undirected graphs]()
# [Neighbour nodes in directed and undirected graphs]()
# [weighted and unweighted graphs]()
# [cyclic and acyclic graphs]()
# [Graphs with Adjacency List]()
# [What is it?]()
# [Why use an adjacency list]()
# [Adjacency List in JavaScript]()
# [Graph Traversal Part I]()
# [DFS recursive exercise]()
# [Breadth-first search]()
# [Edge List to Adjacency List]()
# [Graph Traversal Part II]()
# [Practice: Has Path]()
# [Demo: Number of Forests]()
# [Practice: Largest Forest Area]()
# [BACKTRACKING]()
# [Introduction to Backtracking]()
# [Efficiency]()
# [Terminology]()
# [Permutations]()
# [Optimization]()
# [Problem Solving Approach]()
# [Naive Steps]()
# [Optimization]()
# [Template]()
# [Demo: Permutations]()
# [Practice: Combinations]()
# [CONCLUSION]()
